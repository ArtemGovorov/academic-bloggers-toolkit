import { getFromPMID } from './utils/PubmedAPI';
import { getFromDOI } from './utils/CrossRefAPI';
import { CSLPreprocessor } from './utils/CSLPreprocessor';
import { processDate } from './utils/CSLFieldProcessors';
import { parseInlineCitationString, parseReferenceURLs } from './utils/HelperFunctions';
import { EVENTS } from './utils/Constants';
const { TINYMCE_READY, REFERENCE_ADDED, OPEN_REFERENCE_WINDOW } = EVENTS;

declare var tinyMCE: TinyMCE.tinyMCE;
declare const ABT_locationInfo: ABT.LocationInfo;
declare const wpActiveEditor: string;

tinyMCE.PluginManager.add('abt_main_menu', (editor: TinyMCE.Editor, url: string) => {

    // Fixes issues created if other plugins spawn separate TinyMCE instances
    if (editor.id !== wpActiveEditor) { return; }

    // const eventCreator = (kind: string) => {
    //
    // };


    editor.addShortcut(
        'meta+alt+r',
        'Insert Formatted Reference',
        dispatchEvent.bind(null, new CustomEvent(OPEN_REFERENCE_WINDOW))
    );
    // editor.addShortcut('meta+alt+r', 'Insert Formatted Reference', () => {
    //     const x = new CustomEvent(shortcuts.REFERENCE_WINDOW);
    //     window.dispatchEvent(x);
    // });


    interface RefImportPayload {
        filename: string;
        payload: { [id: string]: CSL.Data };
        format: string;
        links: boolean;
    }

    const importRefs: TinyMCE.MenuItem = {
        text: 'Import RIS file',
        onclick: () => {
            editor.windowManager.open({
                title: 'Import References from RIS File',
                url: ABT_locationInfo.tinymceViewsURL + 'import-window.html',
                width: 600,
                height: 10,
                params: {
                    preferredStyle: ABT_locationInfo.preferredCitationStyle,
                },
                onclose: (e) => {
                    // If the user presses the exit button, return.
                    if (Object.keys(e.target.params).length === 0) {
                        return;
                    }

                    editor.setProgressState(1);
                    let data: RefImportPayload = e.target.params.data;

                    let processor = new CSLPreprocessor(ABT_locationInfo.locale, data.payload, data.format, (citeproc) => {
                        let payload = processor.prepare(citeproc);

                        if (data.links) {
                            payload = parseReferenceURLs(payload);
                        }

                        deliverContent(payload, { attachInline: false, });
                    });
                },
            } as TinyMCE.WindowMangerObject);
        },
    };


    /**
     * Responsible for serving the reference payload once generated.
     *
     * @param  {Error|string[]} data Either an array of formatted references or
     *   an error, depending on if one was received from an external request.
     * @param  {Object}  payload     An object containing an inner boolean
     *   property who's key is `attachInline`. This determines wheter or not a
     *   URL is generated and served after the citation.
     */
    function deliverContent(data: string[], payload: { attachInline: boolean }): void {
        let smartBib = generateSmartBib();
        let reflist: number[] = [];

        data.forEach((ref) => {
            let li = document.createElement('LI') as HTMLLIElement;
            li.innerHTML = ref;
            smartBib.appendChild(li);
            reflist.push(smartBib.children.length - 1);
            dispatchEvent(new CustomEvent(REFERENCE_ADDED, { detail: ref, }));
        });

        if (payload.attachInline) {
            editor.insertContent(
                `<span class="abt_cite noselect mceNonEditable" contenteditable="false" data-reflist="[${reflist}]">` +
                `[${parseInlineCitationString(reflist.map(i => i + 1))}]</span>`
            );
        }

        editor.setProgressState(0);
    }


    /**
     * Generates a Smart Bibliography in the editor and returns the associated
     *   HTMLOListElement.
     * @return {HTMLOListElement} The Smart Bibliography Ordered List.
     */
    function generateSmartBib(): HTMLOListElement {
        let doc: HTMLDocument = editor.dom.doc;
        let existingSmartBib: HTMLOListElement = doc.getElementById('abt-smart-bib') as HTMLOListElement;

        if (!existingSmartBib) {
            let container = doc.createElement('DIV') as HTMLDivElement;
            let smartBib = doc.createElement('OL') as HTMLOListElement;
            let horizontalRule = doc.createElement('HR') as HTMLHRElement;
            let comment = doc.createComment(`Smart Bibliography Generated By Academic Blogger's Toolkit`);

            container.id = 'abt-smart-bib-container';
            container.className = 'mceNonEditable';
            container.contentEditable = 'false';
            smartBib.id = 'abt-smart-bib';
            horizontalRule.className = 'abt_editor-only';

            container.appendChild(comment);
            container.appendChild(horizontalRule);
            container.appendChild(smartBib);

            doc.body.appendChild(container);

            return smartBib;
        }

        return existingSmartBib;
    }


    // TinyMCE Menu Items
    const separator: TinyMCE.MenuItem = { text: '-', };

    const requestTools: TinyMCE.MenuItem = {
        text: 'Request More Tools',
        onclick: () => {
            editor.windowManager.open({
                title: 'Request More Tools',
                body: [{
                    type: 'container',
                    html:
                    `<div style="text-align: center;">` +
                    `Have a feature or tool in mind that isn't available?<br>` +
                    `<a ` +
                    `href="https://github.com/dsifford/academic-bloggers-toolkit/issues" ` +
                    `style="color: #00a0d2;" ` +
                    `target="_blank">Open an issue</a> on the GitHub repository and let me know!` +
                    `</div>`,
                }, ],
                buttons: [],
            });
        },
    };

    const keyboardShortcuts: TinyMCE.MenuItem = {
        text: 'Keyboard Shortcuts',
        onclick: () => {
            editor.windowManager.open({
                title: 'Keyboard Shortcuts',
                url: ABT_locationInfo.tinymceViewsURL + 'keyboard-shortcuts.html',
                width: 400,
                height: 70,
            });
        },
    };

    // Event Handlers
    editor.on('init', () => {
        // addEventListener(abtGlobalEvents.INSERT_REFERENCE, openFormattedReferenceWindow.bind(null, editor));
        dispatchEvent(new CustomEvent(TINYMCE_READY));
    });

    // editor.on('remove', () => {
    //     // removeEventListener(abtGlobalEvents.INSERT_REFERENCE, openFormattedReferenceWindow);
    // });


    // Register Button
    const ABT_Button = {
        id: 'abt_menubutton',
        type: 'menubutton',
        icon: 'abt_menu dashicons-welcome-learn-more',
        title: 'Academic Blogger\'s Toolkit',
        menu: [
            importRefs,
            separator,
            keyboardShortcuts,
            requestTools,
        ],
    };
    editor.addButton('abt_main_menu', ABT_Button);

});
