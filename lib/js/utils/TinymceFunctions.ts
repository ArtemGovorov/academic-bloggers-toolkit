declare var ABT_locationInfo;

/**
 * Opens `reference-window.tsx` and returns a promise which resolves to either
 *   `ABT.ReferencePayload` or `null` on close.
 * @param editor   The active TinyMCE instance.
 * @return A Promise which resolves to ABT.ReferenceWindowPayload
 */
export function referenceWindow(editor: TinyMCE.Editor): Promise<ABT.ReferenceWindowPayload> {
    return new Promise((resolve, reject) => {
        editor.windowManager.open({
            title: 'Insert Formatted Reference',
            url: ABT_locationInfo.tinymceViewsURL + 'reference-window.html',
            width: 600,
            height: 10,
            params: {
                baseUrl: ABT_locationInfo.tinymceViewsURL,
            },
            onclose: (e) => {
                if (!e.target.params.data) resolve(null);
                resolve(e.target.params.data as ABT.ReferenceWindowPayload);
            },
        });
    });
};

export function importWindow(editor: TinyMCE.Editor): Promise<ABT.ImportWindowPayload> {
    return new Promise((resolve, reject) => {
        editor.windowManager.open({
            title: 'Import References from RIS File',
            url: ABT_locationInfo.tinymceViewsURL + 'import-window.html',
            width: 600,
            height: 10,
            onclose: (e) => {
                if (!e.target.params.data) resolve(null);
                resolve(e.target.params.data as ABT.ImportWindowPayload);
            },
        });
    });
}

interface CitationPositions {
    /** The index of the HTMLSpanElement being inserted */
    currentIndex: number;
    locations: [Citeproc.CitationsPrePost, Citeproc.CitationsPrePost];
}

/**
 * Iterates the active TinyMCE instance and obtains the citations that come both
 *   before and after the inline citation being inserted currently. Also receives
 *   the index of the current citation within the document (ie, if there's one
 *   citation before and one citation after the current citation, `currentIndex`
 *   will be 1).
 * @param editor The active TinyMCE instance.
 * @return Parsed citation data.
 */
export function getRelativeCitationPositions(editor: TinyMCE.Editor): CitationPositions {
    const selection = editor.selection;
    const doc: Document = editor.dom.doc;

    const cursor = editor.dom.create('span', { id: 'CURSOR', class: 'abt_cite'});
    selection.getNode().appendChild(cursor);

    const citations = doc.getElementsByClassName('abt_cite');
    const payload: CitationPositions = {
        currentIndex: 0,
        locations: [[], []],
    };

    if (citations.length > 1) {
        let key = 0;
        Array.from(citations).forEach((el, i) => {
            if (el.id === 'CURSOR') {
                key = 1;
                payload.currentIndex = i;
                return;
            }
            payload.locations[key].push([el.id, i - key]);
        });
    }
    let el = editor.dom.doc.getElementById('CURSOR');
    el.parentElement.removeChild(el);
    return payload;
}

/**
 * Updates the editor with inline citation data (citation clusters) generated
 *   by the processor.
 *
 * `reparseExisting` is a boolean which represents wheter or not the function
 *   should be inserting a new HTMLSpanElement, or if it just needs to refresh
 *   the current editor state, either due to a style change or on first init
 *   using cached data.
 * @param  editor   Active TinyMCE editor.
 * @param  clusters Citeproc.CitationClusterData[] generated by the processor.
 * @param  reparseExisting see above note.
 */
export function parseInlineCitations(editor: TinyMCE.Editor, clusters: Citeproc.CitationClusterData[], reparseExisting: boolean = false): void {
    for (const [i, item] of clusters.entries()) {
        if (i === 0 && !reparseExisting) {
            editor.insertContent(`<span id='${item[2]}' class='abt_cite noselect mceNonEditable'>${item[1]}</span>`);
            continue;
        }
        const citation: HTMLSpanElement = editor.dom.doc.getElementById(item[2]);
        citation.innerHTML = item[1];
    }
}
